
怎么访问网站
    DNS: 域名解析，比如一个网站在互联网中是通过IP地址获取的，
    但是为了方便记录会使用域名，域名根IP地址是无法互通的 此时就需要把域名解析成IP地址


vmWare网络
    vmware在安装完成之后 会在本机的网络链接中出现两个虚拟网卡'VMnet1'和'VMnet8'，同样的在VMware中也可以在网络适配器中选择对应的网络连接
        桥接模式：使用本机的真实的端口进行通信，可以连接本机 可以连接局域网 可以连接公网
            由于本机有两块虚拟网卡'有线网络'和'无线网卡'，桥接的时候是自动获取 所以有可能获取到无线网卡或者有线网络 导致网络连接失败
            在'虚拟网络编辑器'中指定要连接的网卡

        NAT模式：使用VMnet8虚拟网卡进行通信，不可以连接局域网

        仅主机模式：使用VMnet1虚拟网卡进行通信，不可以连接局域网 不可以连接公网

配置IP地址
    在命令行窗口输入'setup / nmtui'命令即可使用linux的图形化界面配置IP地址。
    也可以在' /etc/sysconfig/network-scripts/ifcfg-ens33 '内配置
    配置完之后使用' service network restart '重启网卡

    重启可能会失败，大概率是因为IP冲突 改IP就行了。或者就是克隆了虚拟机 导致网卡配置文件中的UUID值重复了，
    当两个虚拟机的UUID一致时就会重启失败。此时就需要删除网卡配置文件中的MAC地址 以及UUID的绑定文件，因为UUID是根据MAC地址计算出来的。


注意事项：
    linux可以使用重启命令 不建议使用关机命令，因为机房中的服务器关机之后还得跑过去打开，而且服务器正在运行的时候突然关机会对硬盘造成损坏
        ' shutdown -r now '安全的重启，会正常保存和中止服务器中正在运行的程序
        ' sync '命令可以让暂时保存在内存中的数据同步到硬盘上，尽量在重启前多执行几次

    Linux一切皆文件
        linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件。这和windows是不同的 windows是通过设备管理器来管理硬件的。
        linux的设备文件在/dev/目录中，硬盘文件是/dev/sd[a-p]，光盘文件是/dev/hdc等

    Linux不靠扩展名区分文件类型
        比如windows中的文本文件就是'.txt' 没有扩展名系统就不知道怎么打开文件。
        linux中不依赖扩展名区分文件类型 而是依赖权限标识符来确定文件类型的 可执行文件只不过是普通文件被赋予了可执行的权限而已。

    不要在服务器访问的高峰期运行高负载的命令
        这样可能会造成服务器响应缓慢甚至死机宕机，高负载命令比如复制大量数据、压缩解压缩文件、大范围的硬盘搜索
        如果对服务器进行备份等操作时 最好用定时任务在访问量不大的时候进行备份

    远程配置防火墙时不要把自己踢出服务器
        防火墙基本功能是数据包过滤(IP、MAC地址、端口号、协议类型、数据包中的数据)
        简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器要想在公网中安全地使用，
        就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和
        有害数据包全部过滤掉，导致自己也无法正常登录服务器，如防火墙关闭了远程连接的SSH服务的端口。

        防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了。

        如何避免这种尴尬的情况发生呢?最好的方法当然是在服务器本地配置测试一下，没问题了再上传到服务器上
        或者使用一个笨方法：先写一个系统定时任务，让它每5分钟清空一下防火墙规则，
        就算写错了也还有反悔的机会，等测试没有问题了再删除这个系统定时任务


linux的目录结构
    一级目录
        /bin/：存放系统命令的目录 普通用户和超级用户都可以执行，是/usr/bin/目录的软链接
        /sbin/：存放系统命令的目录 只有超级用户才可以执行。是/usr/sbin/目录的软链接
        /user/bin/：存放系统命令的目录 普通用户和超级用户都可以执行
        /user/sbin/：存放系统命令的目录 只有超级用户才可以执行
        /boot/：系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等。如果这个文件没了系统一定启动失败
        /dev/：设备文件保存位置
            /dev/cdrom：光盘设备文件名
        /etc/：配置文件保存位置。系统内所有采用默认安装方式(rpm安装）的服务配置文件全部保存在此目录中，
            如用户信息、服务的启动脚本、常用服务的配置文件等
        /home/：普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，
            所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/
        /lib/：系统调用的函数库保存位置 所有包含'so'的文件都是函数。是/usr/lib/的软链接
        /lib64/：64位函数库保存位置。是/usr/lib64/的软链接，
        /lost+found/：当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。
            当系统启动的过程中 fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，
            例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录。
        /media/：挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘
        /misc/：挂载目录。系统建议用来挂载NFS服务的共享目录。我们在刚刚已经解释了挂载，
            童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、/misc，
            但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如超哥接触Linux的时候，默认挂载目录只有/mnt一个，
            所以养成了在/mnt下建立不同目录挂载不同设备的习惯。如/mnt/cdrom 挂载光盘，/mnt/usb挂载U盘，这都是可以的。
        /mnt/：挂载目录。早期Linux中只有这一个挂载目录，并没有细分。
            现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘和其他操作系统的分区。
        /opt/：第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。
            不过超哥还是习惯把软件放到/usr/local/目录中，也就是说，/usr/local/目录也可以用来安装软件
        /proc/：虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。
            主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，
            /proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net是保存网络协议信息的
        /sys/：虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息
        /root/：root的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在“/”下
        /run/：系统运行时产生的数据，如ssid，pid等相关数据。/var/run/是此目录的软链接
        /srv/：服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据临时目录。
            系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入
        /tmp/：我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空
        /usr/：系统软件资源目录。注意usr不是user的缩写，而是“UNIX Software Rescurce”的缩写，
            所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里

    二级目录
        /usr/lib/：应用程序调用的函数库保存位置
        /usr/local/：手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置
        /usr/share/：应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录
        /usr/src/：源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。
            不过超哥更习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中
        /usr/src/kernels/：内核源码保存位置
        /var/：动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件
        /var/www/html/：RPM包安装的Apache的网页主目录
            /etc/httpd/conf/httpd.conf：Apache服务的配置文件
        /var/lib/：程序运行中需要调用或改变的数据保存位置。如MySQL的数据库保存在/var/lib/mysql/目录中
        /var/log/：系统日志保存位置
        /var/run/：一些服务和程序运行后，它们的PID（进程ID）保存位置。是/run/目录的软链接
        /var/spool/：放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列
        /var/spool/mail/：新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中
        /var/spool/cron/：系统的定时任务队列保存位置。系统的计划任务会保存在这里
        /lib/modules/系统版本号/kernel：存放驱动的，'.ko'结尾的就是驱动文件
        /var/lib/rpm/：RPM包的数据库目录
        /etc/rc.d/init.d/ | /etc/init.d/：服务存放的地方，service命令启动服务就需要在这里面找服务
        /etc/yum.repos.d： yum源，文件的扩展名是'.repo'结尾的
        /etc/skel： 文件目录模板，当一些目录(比如用户目录)被创建时，就会自动把此目录中的文件都拷贝过去。


-----------------------------------------------------------------------------------------------------------------------------------------

文件系统
    分区
        分区是把大分区分成逻辑上的小分区 为了存储上的存取方便
        挂载：linux中所有存储设备都必须挂载使用 包括硬盘。就是把已经建立的设备名跟一个空目录连起来的过程。


        在分区中 数据是存储在block块中，一个block块只能存储4KB数据，那么一个100MB的数据 就需要四千多万个block块，这样找起block块来显然是很难的。
        在分区中 有一个超级块区(超级块是用来记录分区的基本信息的)和block块区。由于block块太多了 就会把block分成一个一个的block块组。
            super block(超级块)：记录整个文件系统的信息，包括block与inode的总量、已使用和未使用的inode与block块数量，
                以及他们的大小、文件系统的挂载时间、最后一次的写入时间、最后一次的磁盘检验时间等信息。(dumpe2fs -h 分区名：查看所有超级块)

            date block(block数据块):用来实际保存数据的，block的大小(1KB、2KB或4KB)和数量在格式化后就已经决定，
                不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block块，
                那么这个block的剩余空间不能被其他文件索要;要是文件数据大于一个block块，则占用多个block块。

            inode (i节点):用来记录文件的权限(r、w、x)，文件的所有者和属组，文件的大小，文件的状态改变时间(ctime)，
                文件的最近一次读取时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占用一个inode。


    创建一个分区需要四步
        1.创建分区
            两种分区表形式
                MBR分区表:最大支持2.1TB硬盘，最多支持4个主分区 1个扩展分区(主分区和扩展分区最多4个)
                    扩展分区不能写入数据 只能包含更多的逻辑分区(逻辑分区可以写入数据)

                GPT分区表（全局唯一标示分区表): GPT支持9.4ZB硬盘(1ZB=1024EB，1EB=1024PB，1PB=1024TB)。
                    理论上支持的分区数没有限制，但windows限制128个主分区

        2.格式化
            格式化(高级格式化)又称逻辑格式化，它是指根据用户选定的文件系统如FAT16、FAT32、NTFSEXT2.EXT3、EXT4等，
            在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。

            分区创建完成之后 系统并不知道这是一个分区，所以需要一些操作来让系统认识这个分区。此时就需要格式化，
            格式化并不仅是清空数据用的，格式化是为了写入文件系统，顺便把数据清空

            磁盘上 会先划分出两个区域 一个区域内会有存放很多的block(数据块) 一个数据块默认4KB，block是用来存储数据用的
                一个10KB的数据 那么就会存到三个block上，系统会尽量让这三个block放在一起，因为在一起的block读取的时候会比较快
                一个10KB的数据 存到第三个block上 肯定是会有一个block还剩2KB数据 此时这2KB是不能在存储数据的，因为存储数据的最小单位是4KB

            而另一个区域内会存放Inode，Inode有一个唯一的I节点号 Inode中保存了block的位置(Inode 默认128B大小)、文件的时间、文件的权限，
                获取文件的时候就需要先通过I节点号找到Inode。Inode写满了后即使磁盘还有存储空间 也是存储不了数据的，所以不要上传一些空白的文件等。
                可以通过I节点号找到数据 那去哪查找I节点号？当前文件的I节点号保存在上级文件的block中，顶级文件就是根目录 根目录的I节点号默认是2。

        3.硬件设备文件名
            在windows中 由于是图形化界面 所以格式化之后就可以使用了。
            但是在linux中 格式化之后的分区系统是找不到的 所以就需要指定' 硬件设备文件名 '，有了名称之后系统就可以找到该分区

            设备硬件设备文件名(就是进入分区访问数据的入口 相当于盘符)：
                /dev/hda1(IDE硬盘接口)
                /dev/sda1(SCSI硬盘接口、SATA硬盘接口√)：第一块SATA接口硬盘的第一个主分区
                /dev/sdb5：第二块SATA接口硬盘的第一个逻辑分区。因为1至4固定是主分区的名称，5是扩展分区的第一块逻辑分区

        4.指定挂载点
            linux中挂载点是使用'已存在的空目录作为挂载点'。
            挂载就是把' 指定过设备硬件名的分区 跟 已存在空目录 '进行连接的过程，连接之后这个空文件就可以当作是分区了。
            一个挂载点下必须有'/'根分区、'swap'交换分区、'/boot'启动分区三个分区
                其中根分区是存储数据的。
                交换分区是虚拟内存 当真实内存不够的时候 会使用虚拟内存来顶替内存。
                启动分区是防止硬盘写满数据后 系统启动失败的，因为系统启动时会需要一些硬盘空间 如果没有硬盘则会启动失败。

        Linux中所有的存储设备都必须在挂载之后才能使用
            Linux中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U盘和光盘。
            挂载其实就是给这些存储设备分配盘符，只不过 Windows中的盘符用英文字母表示,而Linux中的盘符则是一个已经建立的空目录。
            我们把这些空目录叫作挂载点(可以理解为Windows的盘符），把设备文件（如/dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载


                        -------------------------------------------------------------

手动创建分区
    0. 在VM上手动添加一块硬盘，重启虚拟机。重启之后可能会发生网卡连接失败的情况，原因是网卡的UUID重复。
    1. fdisk /dev/sdb
        进入交互指令说明 进行磁盘分区，可以先用fdisk -l查看所有系统分区以及磁盘分区
        n：新建分区
        d：删除分区
        p：打印分区
        l：显示已知文件系统类型和其ID号
        t：改变文件系统类型和其ID号
        w：保存所有操作退出
        q：取消执行的操作退出

        按n创建分区，会有两个选项：p(创建主分区)、e(创建扩展分区)。然后会让指定起始扇区和结束扇区(给分区分配的大小)。
        创建逻辑分区后 按'n'后的选项就会变成：p(创建主分区)、l(创建扩展分区)。创建分区完成 按'p'查看所有分区。

    2. 格式化 建立文件系统
        mkfs -t ext4 /dev/sda1： 格式化分区
            -t： 指定文件系统为ext4
            /dev/sda1： 创建的主分区/逻辑分区的名字

    3. 建立挂载点 空目录
        mkdir /disk1

    4. 挂载目录 分区必须格式化才可以
        mount [选项] /dev/sdb1 /disk1
            -t：指定操作系统
            -a：扫描配置文件'/etc/fstab'的内容 自动挂载

    5. 查看挂载结果
        mount ：查看所有已经挂载的分区和光盘
        fdisk -l ：查看所有系统分区以及磁盘分区
        df ：查看文件系统的资源使用情况

    6. 自动挂载
        手动挂载完成之后，重启一下挂载好的分区就会失效。所以需要让系统在开机之后自动挂载
        自动挂载需要在' /etc/fstab '内添加分区的uuid值，uuid值在'/dev/disk/by-uuid/'下面，或者使用'blkid'查看
            修改/etc/fstab配置文件
                UUID=eea96004-d435-45d5-bcd6-b529877fc39a /disk1 ext4 defaults 0 0
                    第一列：设备文件名。
                    第二列：挂载点。
                    第三列：文件系统。
                    第四列：挂载选项。
                    第五列：是否可以被备份(0不备份 1每天备份 2不定期备份)
                    第六列：是否检测磁盘fsck(0不检测 1启动时检测 2启动后检测)

            如果/etc/fstab配置文件内的内容写错 就会造成系统开机启动失败的问题。系统如果启动失败 就需要在本机上进行操作。
                使用mount -o remount,rw / 重新挂载文件，然后修改配置文件即可。


    parted 命令分区
        Linux中的分区表有两种：MBR(只支持2TB数据 最多四个分区)、GPT(支持18EB 最多支持128个分区)。
        fdisk命令只支持MBR表分区，想要给GPT表进行分区 就需要使用parted命令


                        -------------------------------------------------------------

系统管理命令
    df [选项] [目录或文件名]
        查看文件系统的资源使用情况
        -a：显示所有文件系统 包括系统特殊文件系统
        -h：人性化显示所占大小的显示方式
        -T：显示文件系统的类型

    du [选项] [目录或文件名]
        用来统计文件或者目录的大小 (ll命令是不统计文件目录的大小的，因为目录的block存放的是子文件的名称等信息)
        -a：显示每个子文件的磁盘占用量，默认只统计子目录的磁盘占用量。
        -h：人性化显示所占大小的显示方式。
        -s：只显示统计出来的总占用量

    注意：df统计的是空间大小 统计的剩余空间是准确的，系统在运行期间所产生的临时文件也会占用空间大小，所以可能会比du统计的结果多很多。
            du统计的是文件大小 统计的文件大小是准确的。


    fdisk -l
        查看所有分区的信息

    free -h
        查看Mem(内存)和swap(缓冲 缓冲是在Mem占满之后使用的)的使用情况
                      total        used(已用)  free(可用)   shared  buff/cache   available
        Mem:           3.7G        408M        2.9G         11M        343M        3.1G
        Swap:          2.0G          0B        2.0G

    stat 文件名
        显示文件的详细信息

    file 文件名：
        判断文件类型
        file aa    --执行结果-->    aa: UTF-8 Unicode text
        file ./    --执行结果-->    ./: directory

    type 命令名：
        判断命令类型，会显示一些命令的类型和说明
        type cd   --执行结果-->   cd 是 shell 内嵌
        type ll   --执行结果-->   ll 是 `ls -l --color=auto' 的别名
        type service   --执行结果-->   service 是 /usr/sbin/service


                        -------------------------------------------------------------

LVM(Logical Volume Manager 逻辑卷管理)
    普通的标准分区都不可以对分区进行扩容。当分区数据满了之后只能在新建一个分区进行，让新的数据存到新的分区。
    而LVM分区可以把新的分区加入到旧的分区上。

    物理卷(PV，Physical Volume):
        就是真正的物理硬盘或分区。

    卷组(VG，Volume Group):
        将多个物理卷合起来就组成了卷组
        组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区。我们可以把卷组想象为一个逻辑硬盘。

    逻辑卷(LV，Logical Volume):
        卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区我们称作逻辑卷。
        逻辑卷可以格式化和写入数据。我们可以把逻辑卷想象成为分区。

    物理扩展（PE，Physical Extend):
        PE是用来保存数据的最小单元，我们的数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB.

    过程
        1. 首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。
        2. 然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。
        3. 接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组。
        4. 最后就是把卷组再划分成为逻辑卷(LV)，逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。

    操作
        创建物理卷
            使用fdisk 创建新的分区(LVM的分区ID号是8e，不是83)，创建完成后不用格式化
            pvcreate 分区名： 把分区创建为物理卷
            pvscan： 查看物理卷
            pvdisplay： 查看物理卷 更纤细的信息
            pvremove： 删除物理卷

        把物理卷组成卷组
            vgcreate 卷组名 物理卷组 ： 把物理卷添加到卷组中
            vgdisplay ： 查看卷组的详细信息
            vgremove 卷组名 ： 删除卷组

        在卷组内划分逻辑卷
            逻辑卷只用指定卷大小即可。不是说卷组内有三个物理卷 就一定要划分三个逻辑卷
            lvresize -L 容量 逻辑卷名
                扩容逻辑卷大小。只要'卷组'还有剩余空间，'逻辑卷'就能随意扩容

            lvcreate [选项] 卷组名
                划分逻辑卷，可以想象成分区。划分完需要格式化 挂载
                -L ： 逻辑卷的大小 单位MB、GB、TB。逻辑卷的大小
                -n 逻辑卷名 ： 指定逻辑卷的名称

                mkfs -t ext4 /dev/卷组名/逻辑卷名
                    格式化逻辑卷。逻辑卷需要格式化挂载才能使用

                mount 逻辑卷名 目录
                    把逻辑卷挂载到目录下

            resize2fs 逻辑卷名
                刷新，不刷新的话'df'查看的资源使用情况就还是旧数据

        检验：
            df -h ： 查看文件系统的资源使用情况
            fdisk -l ： 查看所有分区的使用情况


                        -------------------------------------------------------------

磁盘配额
    什么是配额？就是用来限制用户/用户组在这个分区上可以使用的空间和文件大小个数的限制。就是分配使用空间。

    首先需要内核支持磁盘配额：   grep QUOTA /boot/config-2.xxxxxxxx
    需要安装了quota工具：       rpm -qa | grep quota

    用户配额：限制每个用户可用的额度。
    组配额：组配额使用的方式是先到先得，有可能会出现最先来的用户直接把匹配占满，不推荐。

    磁盘容量限制：限制磁盘的容量，即用户可用的容量
    文件个数限制：限制用户上传的文件的个数

    硬限制：实际限制，假如限制100M，那么就只能存储100M。
    软限制：警告空间，假如限制100M，那么到了100M还是可以存储。如果用户的空间占用数处于硬限制和软限制之间，
        系统会在用户登录时警告用户磁盘将满，这个时间就是宽限时间(默认7天)。如果过了宽限时间，用户的配额还是超过了软限制，
        那么软限制将升级为硬限制。


    过程略

