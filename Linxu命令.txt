
帮助命令
    whereis 命令
        查看命令在哪个目录下


目录操作命令
    [root@localhost ~]：
        root是当前用户
        localhost是系统主机名
        ~是当前用户的家目录(root用户的家目录是'/root' 普通用户的是/home/用户名)

    -rw-------. 1 root root     1257 12月 17 2020 anaconda-ks.cfg
        第一列：权限
        第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级目录包括隐藏文件(隐藏文件使用'ls -a'查看)
        第三列：所有者。表示这个文件属于哪个用户，默认所有者是文件的建立用户
        第四列：所有组。默认所属组是文件建立用户的有效组，一般情况就是用户的所在组
        第五列：文件的大小，默认大小是字节
        第六列：文件修改时间
        第七列：文件名

    [root@localhost ~]# ls [选项] [文件名或目录名]
        -a：显示所有文件
        -d：显示目录信息 而不是目录下的文件，(例如'ls -ld ./' 查看当前文件夹的信息)
        -s：文件大小
        -h：人性化显示，按照我们习惯的单位显示文件大小
        -i：显示文件的'i'节点号，i节点号就是分区中block的索引
        -l：长格式显示(完整信息)


    ln 源文件 文件
        在文件之间建立硬链接
        硬链接就是把两个文件链接到一起 链接后的文件I节点号是一样的，修改一个文件的内容另一个文件的内容也会改变、
            删除一个文件 另一个文件也是可以可以使用的。硬链接不能链接目录、不能跨分区。
            原理：硬链接的I节点号和源文件的I节点号是指向的同一个block，所以删除任意一个另一个不受影响

    ln -s 源文件 文件
        创建软链接
        软链接根硬链接基本一致，但是软链接删除源文件后软链接的文件就无法使用了。
            并且软链接两个文件的I节点号和Block都是不相同的，会显示当前文件链接到哪个文件,
            软链接的权限是最大权限，但是只是有访问链接文件的权限 要访问源文件还是要看源文件的权限
            原理：软链接的Block不存放数据 而是存放源文件的I节点号，然后软链接文件的I节点号指向了这个Block。
                所以删除源文件后被链接的文件就无法访问了，但是删除被链接的文件后源文件没事

        --- 源文件 ---      --- 硬链接 ---       |        --- 源文件 ---     --- 软链接 ---
                      Block                     |            Block             Block
            源文件和链接文件的I节点号            |                         软链接的Block存放
                都指向了这个block               |                           源文件的I节点号

文件内容操作命令
    cat 文件：查看文件的内容
        -A：相当于-vET选项的整合 用于列出所有隐藏符号
        -E：列出每行结尾的回车符$
        -T：把Tab键用^I显示出来
        -v：列出特殊字符
        -n：显示行号

    more 文件名
        分屏显示文件内容，使用空格键向下翻页，b键向上翻页，回车向下滚动一行，/字符串搜索指定的字符串，q退出

    less 文件名
        跟more类似 只不过less是一行一行的显示 more是一页一页的显示

    head -20 文件名
        显示文件前面20行数据

    tail -10 文件名
        显示文件尾部10行数据
        -f：监听文件 如果在监听时文件被写入了数据 就会显示出来

文件操作命令
    touch 文件名
        触摸文件，如果文件不存在就创建

    mkdir 文件夹名
        创建文件夹
        -p：创建多级文件夹

    rm 文件名
        删除文件

    rm -r 文件夹名/*
        删除文件夹下所有文件 需要二次确认
        -rf：不需要二次确认删除文件夹以及文件夹下所有文件(删除后的文件无法找回 可以安装一个'extundelete'来恢复数据)

    echo xxx
        输出xxx到控制台上
        >> 文件名：命令重定向。只要是前面的命令有输出结果 就可以使用' >> '重定向写入到文件中(echo xxx >> 文件名)

    stat 文件名
        查看文件的信息，比如文件大小、i节点号、block数、硬链接数量，
        最近访问的时间 最后一次数据修改的时间 最后一次状态修改的时间等信息。linux中没有文件创建时间

    cp [选项] 源文件 目标文件：复制文件
        -i：询问，如果目标文件已经存在，则会询问是否覆盖
        -a：相当于-dpr的集合
        -d：如果源文件为软链接(硬链接无效) 则复制出的目标文件也为软链接
        -p：复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)
        -r：递归复制 用于复制目录

    mv 源文件 目标文件
        移动文件

搜索命令
    grep [选项] "搜索内容" 文件名
        搜索文件中包含指定内容的行(只要包含就会搜索出来)
        -w 文件内容：精确匹配

        包含匹配
            比如搜索了aa 结果出现了aaab 这就是包含匹配 会搜索出包含aa的结果。
        完全匹配
            比如搜索了aa 结果只出现了aa 这就是完全匹配 只会搜索是aa的结果。
        为什么会出现这种结果呢？
            因为命令的不同 底层使用的匹配机制也不同，就比如find命令使用的就是通配符进行匹配，grep使用的是正则表达式(也可以使用-w选项精确匹配)。
            通配符用于匹配文件名 完全匹配。正则用于匹配字符串，包含匹配。

            通配符，完全匹配
                ?：匹配一个任意字符
                *：匹配0个或任意多个任意字符，也就是可以匹配任何内容
                []：匹配中括号内任意一个字符。例如[abc]代表一定匹配一个字符，可以是a、b、c
                [-]：匹配中括号内任意一个字符。-代表一个范围。例如[a-z]代表匹配一个a-z的小写字母
                [^]：逻辑非，表示匹配不是中括号内的一个字符，例如[^0-9]代表匹配一个不是数字的字符

            正则表达式，包含匹配
                ?：匹配一个字符重复0次，或1次。(?是扩展正则，需要使用egrep命令)
                *：匹配前一个字符重复0次，或任意多次
                []：匹配中括号中任意一个字符，例如[abc]代表一定匹配一个字符，或者是a、b、c
                [-]：匹配中括号中任意一个字符，-代表一个范围。例如[a-z]代表匹配一个a-z的小写字母
                [^]：逻辑非，表示匹配不是中括号内的一个字符，例如[^0-9]代表匹配一个不是数字的字符
                ^：匹配行首
                $：匹配行尾

    find 搜索路径 [选项] 文件名
        -name：按照名称搜索
        -iname：按照文件名搜索 不区分大小写
        -inum：按照inode号搜索
        -size +20M：按照文件大小搜索，+20M表示大于20M的

        -user 用户名：按照用户名查找文件所有者是指定用户的文件
        -group 组名：按照组名查找所属组是指定用户组的文件
        -nouser：查找没有所有者的文件

        -atime 时间：按照文件访问时间搜索
        -mtime：按照文件数据修改时间搜索
        -ctime：按照文件状态修改时间搜索

        -a：逻辑与，必须满足两个条件才为真。例如：find ./ -size +2K -a -type f(文件必须是大于2K并且类型是普通文件)
        -o：逻辑或，一个条件为真就都为真
        -not：逻辑非，取反

        -exec：把命令一的结果当作是命令二的参数来使用。例如：find ./ -size +2K -exec ls -lh {} \;
        -ok：和-exec一样 但是ok在处理时会询问

压缩命令
    Linux支持的压缩格式有：.zip  .gz  .bz2  .tar  .tar.gz  .tar.bz2。
    Linux是可以不指定后缀名的 这个后缀是给用户看的
    Linux中'压缩'和'打包'是分开的。压缩是把文件/包压缩，打包是把文件夹/多个文件打成一个包

    压缩
        zip格式
            zip [选项] 压缩包名 源文件或原目录
                -r：压缩目录

            unzip [选项] 压缩包名
                -d：指定解压缩的位置，不指定默认解压到当前目录

        gz格式。只会压缩文件 不能打包
            gzip会把源文件删除后 再创建压缩包，不会打包！
            gzip [选项] 源文件
                -c：将压缩数据输出到标准输出中 可以用于保留源文件
                -d：解压缩
                -f：压缩目录

        bz2格式。只会压缩文件 不能打包
            不能压缩目录，bz2格式是Linux的另一种压缩格式，从理论上来讲，bz2格式的算法更先进、压缩比更好；而gz格式相对来讲压缩的时间更快。
            bzip2 [选项] 源文件
                -d：解压缩
                -k：压缩时 保留源文件
                -v：显示压缩的详细信息

    打包
        tar格式。只会打包，不能压缩。打包之后再压缩，解压之后再解包
        tar格式用-cvf来控制压缩包。其中c位控制压缩/解压 也可以使用t来查看压缩包、f位控制压缩包的名称、v位控制压缩过程。

            tar [选项] [-f压缩包名] 源文件或包名
            tar -cvf xxx.tar /etc
                -c：打包
                -f：指定压缩包的文件名
                -v：显示打包文件过程

            tar -xvf xxx.tar /etc
                -x：解打包
                -f：指定压缩包的文件名
                -v：显示解打包的文件名
                -t：测试 就是不解打包 只是查看包中有哪些文件
                -C：解包到指定目录，必须在最后包名后面指定

        tar格式 压缩加打包
            tar [选项] 压缩包 源文件或目录
            tar -zcvf xxx.tar.gz /etc
                -z：压缩和解压缩'.tar.gz'格式
                -j：压缩和解压缩'.tar.bz2'格式

        怎么解压指定文件？
            tar -ztvf xxx.tar.gz   查看包内的所有文件
            tar -zxvf xxx.tar.gz -C ./test xxx   把包内的xxx文件解压到test目录



关机和重启
    数据是在内存中的，如果内存中的数据还没刷到硬盘中 此时重启就会造成数据丢失。
    sync：把内存中的数据存入到硬盘中

    shutdown [选项] [时间]
        关机/重启电脑，可以指定时间，比如shutdown -r 6:00 六点重启、shutdown -r now 现在重启
        -h：关机
        -c：取消shutdown
        -r：重启，可以指定时间

网络命令
    w：查看当前登录的用户
        USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
        root     pts/0    192.168.32.1     08:00    7.00s  0.14s  0.00s w(当前用户)

    write 用户名称 TTY名称
        给指定用户发送消息，输入完消息之后ctrl+d发送信息

    wall
        给所有用户发送消息

系统痕迹命令
    系统目录下的'/var/log/wtmp'、'/var/run/utmp'、'/var/log/btmp'、'/var/log/lastlog'等日志文件是记录系统登录痕迹的，
    包括某个用户合适登录 退出了系统等重要的系统信息。这些文件都是二进制乱码文件 无法直观的查看，所以就需要特定的命令

    w：对应的是'/var/run/utmp'文件 即用户登录信息
        08:51:16      up 15:15,          2 users,           load average: 0.00, 0.01, 0.05
        当前时间   系统已经运行的时间    登录了两个用户      当前系统的负载(不应该超过当前cpu的核数)

        USER            TTY          FROM        LOGIN@       IDLE         JCPU                 PCPU                    WHAT
        当前登录的用户  登录的终端  登录的IP地址  登录时间  用户闲置时间  所有的进程占用的CPU时间  当前进程占用的CPU时间  用户正在进行的操作

    who
        跟w命令一致 但是这个显示的更简单
        root     pts/0        2021-07-01 08:00 (192.168.32.1)

    last
        查询用户登录的记录 登录过才会记录

    lastlog
        查询所有登陆过的用户的信息 包括未登录过的用户

    lastb
        查询错误登录 被系统拒绝了的操作


挂载命令
    挂载：linux中所有存储设备都必须挂载使用 包括硬盘。就是把已经建立的设备名跟一个空目录连起来的过程。
    挂载光盘
        mount [选项] /dev/cdrom /mnt/cdrom
            -t：指定操作系统
            -a：扫描配置文件'/etc/fstab'的内容 自动挂载

            挂载光盘文件(cdrom是sr0的软链接 sr0是源文件)到指定目录(mnt是挂载目录 挂载目录名称最好跟源文件一样)
            挂载完之后使用mount即可查看所有的挂载信息，有这个信息表示挂载成功：/dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime)

            挂载完之后就可以到/mnt/cdrom目录下访问到挂载到此处的/dev/cdrom文件的内容，
            挂载到此处的数据并不会把原先/dev/cdrom的数据覆盖掉，而是把原先文件的inode指向了/mnt/cdrom。
            所以在拆卸掉/dev/cdrom挂载设备之后 /mnt/cdrom中的数据还是存在的

        umount /dev/sr0
            卸载挂载设备，用完设备之后一定要拆卸

        fdisk -l
            查看系统分区

        mount -t vfat /dev/u盘名称 /mnt/u盘名称/
            挂载u盘，因为u盘的类型和光盘一样 如果名称被光盘占用了 那么u盘的名称可能就会变，所以每次挂载u盘前需要先查询一下


rpm包
    包安装
        rpm -ivh 包全名
            安装rpm包，不建议指定位置 会安装到默认路径。
            -i：install安装
            -v：显示更详细的信息
            -h：打印#显示安装进度
            --force：强制重新安装rpm包，当软件中的一些文件丢失时 可以使用此命令重新安装。

            包全名：如果是未安装的软件包 则使用包全名。
            包名：如果操作的是已经安装的软件包，则使用包名即可，系统会产生RPM包的数据库(/var/lib/rpm/)

        rpm -Uvh 包全名
            -U：安装升级 如果没有安装过 系统直接安装。如果安装过就版本则升级到最新版本

        rpm [选项] 包名
            拆卸rpm包
            -e：拆卸

    包安装
        rpm -ivh 包全名
            安装rpm包，不建议指定位置 会安装到默认路径。
            -i：install安装
            -v：显示更详细的信息
            -h：打印#显示安装进度
            --force：强制重新安装rpm包，当软件中的一些文件丢失时 可以使用此命令重新安装。

            包全名：如果是未安装的软件包 则使用包全名。
            包名：如果操作的是已经安装的软件包，则使用包名即可，系统会产生RPM包的数据库(/var/lib/rpm/)

        rpm -Uvh 包全名
            -U：安装升级 如果没有安装过 系统直接安装。如果安装过就版本则升级到最新版本

        rpm [选项] 包名
            拆卸rpm包
            -e：拆卸

    包查询
        查询是否已安装
            rpm -q 包名：查询软件包是否已安装
                -a：查询系统中所有软件包
                -p：查询没有安装的软件包

        查询包信息
            rpm -qi 包名：查询软件包的详细信息
            rpm -qip 包全名：查询还没有安装的软件包的详细信息

        查询安装位置
            rpm -ql 包名：查询所有已经安装的软件包和这些包的完整目录
            rpm -qlp 包全名：查询所有还没有安装的软件包和打算安装的位置(默认的安装位置，包的作者决定的)

        查询系统文件属于哪个包
            rpm -qf 系统文件名：查询一个系统文件 即可知道此文件属于哪个软件包

    包验证
        rpm -V 已安装的包名：效验指定的rpm包中的文件
        rpm -Vf 系统文件名：效验某个系统文件是否被修改
            S.5....T.       c           /etc/http/conf/httpd.conf
            其中 S.5....T. 就是效验内容 有八个属性
                S：文件大小是否改变          M：文件的类型或文件的权限(rwx)是否改变
                5：文件MD5效验和是否改变(可以看成文件内容是否改变)              D：设备的主从代码是否改变
                L：文件路径是否改变          U：文件的属主(所有者是否改变)   G：文件的属组是否改变     T：文件的修改时间是否改变

                c：文件类型是配置文件           d：文件类型是普通文件
                g：文件类型是"鬼"文件，就是该文件不应该被这个rpm包包含          l：授权文件               r：描述文件

        要注意的是 包验证有一个原始值，验证的结果就是跟这个原始值作比较，判断值是否发生了改变。
        那么原始值要是被改变了呢？使用数字证书，证书用来保证原始值的安全
            首先需要找到原厂的公钥文件 然后进行安装。安装rpm包的时候就会去提取rpm包中的证书的信息 然后和本机安装的原厂证书进行效验。
            效验通过则允许安装；不通过则不允许安装。证书文件：RPM-GPG-KEY-xxxxxx
            导入数字证书：rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
            查询数字证书：rpm -qa | grep gpg-pubkey



其他命令
    管道符' | '
        管道符是文本流操作。就类似把命令一的执行结果写入到了文件中。只要加了管道符 不管前面的操作是什么，后面的操作都是字符串。
        ll /etc | find 文件： 错误，因为加了管道符ll的结果就是文本了 应该使用文本操作，非得使用find就得用'-print'把find的内容输出。
        netstat -an | grep LISTEN | wc -l： 正确用法，管道符可以多个嵌套 只要上一个管道符有输出结果

        管道符是把命令一的结果转为字符串然后作为命令二的输入参数来使用，

    netstat [选项]：
        查询所有开启了的端口
        -p：查看是哪个程序占用了此端口
        -r：显示网关，netstat -rn
        -a：显示所有网络状态，包括谁在连接本机等
        -n：使用IP地址和端口号显示，不使用域名与服务名
        -t：显示使用TCP协议端口号连接状况
        -u：显示使用UDP协议端口号连接状况
        -l：仅显示监听状态的连接

    alias
        起别名，查看已经起过别名的命令。
        也可以用来起别名(临时生效)，别名会把原先的系统命令覆盖掉。比如起了个别名ll 那么原先的系统命令ll就失效了。
        想永久生效需要修改'~(家目录 普通用户在/home内)/.bashrc'
        alias ser='service network restart'： 把重启网卡的操作用ser代替。


vi命令
    vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版

    vi [选项] 文件名 文件名
        -o：同时编辑两个文件 上下分屏
        -O：同时编辑两个文件 左右分屏

    vi 文件名
        进入文本编辑页面
        插入模式
            a：在光标后插入
            A：在光标所在行行尾插入
            i：在光标前插入
            I：在光标所在行行首插入
            o：在光标下插入新行
            O：在光标上插入新行

        编辑模式
            :w：保存不退出
            :w：新文件名：把文件另存为新文件
            :q：不保存退出
            :q!：强制不保存退出
            :wq：保存退出
            :wq!：强制保存退出，当文件的所有者或者root用户，对文件没有写权限的时候，强制写入数据使用
            :66：输入指定的行号即可移动到指定行
            :r 文件名：把文件内容导入到光标位置
            :!命令：在vim中执行系统命令
            :r !命令：把命令的执行结果写入到当前文件内

            查找
                :/：从光标行向下搜索
                :?：从光标行向上搜索
                n：下一个
                N：上一个

            替换
                :1,10s/old/new/g：替换第一行到第十行 所有old为new
                :%s/old/new/g：替换整个文件的old为new
                :1,10s/^/#/g：注释第一行到第十行
                :1,10s/^#/ /g：取消注释第一行到第十行

        快捷键
            h、j、k、l：左下上右
            gg：光标移动到文件头
            G：光标移动到文件尾
            ^：移动到行首
            $：移动到行尾

            dd：删除一行
            ndd：删除多行 比如'6dd'
            dG：从当前行删除到文件尾

            yy：复制单行
            nyy：复制多行

            p：粘贴到光标后
            P：粘贴到光标前

            u：撤销
            ctrl+r：反撤销

            :set nu：显示行号
            :set list：显示隐藏符号
            :set nolist：取消显示隐藏符号


        补充
            windows下回车符在Linux中是用" ^M$ " 而不是" $ "符号。这样会导致windows下编辑的程序脚本无法在Linux中执行，
            这时可以使用命令" dos2unix "，把windows格式转换为Linux格式，反过来命令是" unix2dos "命令。

