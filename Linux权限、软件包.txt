
linux中的权限有六种
    文件读写执行权限
    umask默认权限
    ACL忽略组直接给用户赋予权限
    sudo给用户指定可以执行的命令
    SUID、SGID特殊权限
    chattr不可改变位权限


                        -------------------------------------------------------------

帮助命令
    whereis 命令： 查看命令在哪个目录下


                        -------------------------------------------------------------

目录权限
    -rw-r--r--. 1 root root      995 6月  28 11:59 aa
        第一位代表文件类型
            '-' 表示普通文件
            'd' 目录文件，linux中一切皆文件 所以目录也是文件的一种
            'l' 软链接文件

        第2-4位表示所有者的权限，所有者就是权限后面第一个的root
            'r' 读取权限
            'w' 写入权限
            'x' 执行权限

        第5-7位表示所属组的权限，所属组就是权限后面第二个的root
            如果所有者在所属组内(比如root用户在root组内) 就会使用所有者的权限
            但是如果root组内有多个用户，那么组内除了初始用户的其他用户都会使用所属组的权限

        第8-10表示所有其他用户的权限


    修改权限
        chmod u+x,g+r,o-w 文件
            u表示所有者、g表示所属组、o表示其他用户。r是读权限、w是写权限、x是执行权限

        chmod 755 文件
            4表示读权限、2表示写权限、1表示执行权限。
            755就表示该文件的所有者的执行权限为读写执行、所属组是读执行、其他用户是读执行。

        chown 用户:用户组 文件
            修改文件的所有者和所属组

        chgrp 用户组 文件
            修改文件的所属用户组

        umask 0022
            修改umask权限，临时修改(永久修改需要修改'/etc/profile'配置文件)
            文件的默认权限002 意思是：666-002=rw- rw- r--
            目录的默认权限是022 意思是：777-022=rw- r-- r--

    注意事项
        普通用户也可以修改文件的权限 但是只能修改自己的文件的权限。不可以修改文件的所有者，哪怕文件是自己的。
        文件有写的权限 那么可以进行写操作 但不一定可以删除此文件。因为当前文件的inode号是存放在父目录的block中，父目录没有写权限就不行。


                        -------------------------------------------------------------

用户配置
    当分权限的时候 应该先搞清楚：所有者是谁、所属组是谁。知道了所属组之后 就需要给组一个合适的权限 因为组内其他用户都是使用所属组的权限。
    组内最大就是初始用户，所以初始用户应该是rwx。而组权限也可以是rwx，不用担心其他用户会胡来 因为还有其他权限控制的方法。

    用户的创建删除
        新建用户系统会做三件事
             新建用户时，系统会将 /etc/skel 中的目录及文件拷贝到新建用户的家目录 /home/中
             在 /var/spool/mail 中，新建用户名的邮箱
             在 /etc下的 passwd 、shadow 、group文件中，增加用户信息

        新建用户
            useradd 用户名
                -u UID：指定用户的uid，如果指定为550 那么后面创建的用户的默认uid就是从550开始计算
                -g 组名：指定初始组
                -G 组名：指定附加组

            passwd [选项] 用户名
                给用户添加密码，没有密码的用户是无法进行登录的(系统的伪用户除外)。
                -l：暂时锁定用户 仅root可以使用此命令
                -u：解锁用户 仅root可以使用此命令
                --stdin 用户名：可以将管道符的输出结果作为用户密码 在批量添加用户时使用( echo "xxx" | passwd --stdin 用户名 )

        切换用户
            su [选项] 用户名
                - ：连着用户的环境变量一起切换。不加'-'的话，切换过用户后 使用env查看系统变量的时候，还是原先用户的环境。
                -c：仅执行一次命令。而且不切换用户身份

        删除用户
            userdel [选项] 用户名
                -r：删除用户的时候同时删除用户的家目录

        手动删除用户
            编辑/etc/passwd(用户信息文件)、/etc/shadow(用户密码文件)、
                /etc/group(用户组文件)、/etc/gshadow(用户组密码文件)，将这些文件内的用户行信息删除。
            删除用户家目录/home/组名、
            删除用户邮箱目录/var/spool/mail/组名

        修改用户信息
            usermod [选项] 用户名
                -u UID：修改用户的UID
                -d 家目录：修改用户的家目录，必须写绝对路径
                -c 用户说明：修改用户的说明信息，就是/etc/passwd文件的第五个字段
                -g 组名：修改用户的初始组，就是/etc/passwd文件的第四个字段
                -G 组名：修改用户的附加组，就是把用户添加到其他用户组
                -e 日期：修改用户的失效日期。格式为'YYYY-MM-DD' 就是/etc/shadow文件的第八个字段


    用户组操作
        groupadd 组名：
            创建用户组

        groupdel 组名：
            删除用户组，删除组之前必须先删除组内的初始用户 因为初始用户必须有一个初始组。

        gpasswd [选项] 组名：
            对用户组内操作
            -a：把用户添加到用户组内
            -d：把用户从组中删除


    用户的信息配置文件
        /etc/passwd 用户的信息文件
        root:x:0:0:root:/root:/bin/bash
            root:   用户名。
            x:      密码位。有这个表示用户有密码 有密码就会去/etc/shadow内验证
            0:      用户id。0表示超级用户、1-499表示系统用户 不可以登录 是用来启动对应的程序的、500-65535：普通用户使用。
            0:      初始组ID。新用户会自动生成一个跟用户名一致的初始组
            root:   用户说明
            /root:  用户的家目录
            /bin/bash：  用户登录之后有的权限，/bin/bash是可以执行自己权限内的所有权限

            linux中用户权限是绑定的用户id位，想要把普通用户改为root用户 就需要把用户的用户id位修改为0。


        /etc/shadow 用户密码文件
        root:$6$/0u/sh2xNnXLEwPz$RHadobxQxLue8Ixk1hx8vGoapq0CxgiPTN.S7.R13cZmWCrVZYbo2FD7h2a/pgL8riXBBHiSZ2Ee7Xza8GFEA0::0:99999:7:::
            root:   用户名
            第二列: 用户密码 使用md5集合用户名、用户密码、当前时间计算得出。
                这是一个加密密码值 如果修改起其内容 那么最终就无法计算出密码，所以如果想要让用户暂时不能登录 就在密码前加一个'!'
             :：    更新密码的时间。时间戳格式
            0:      两次密码的修改间隔时间(和第三字段相比)
            99999:  密码的有效期(和第三字段相比，每次修改密码都会重新计算)
            7:      密码到期前的警告天数(和第五字段相比)
             :：    密码到期后的宽限天数，为空表示-1(永不过期，和第五字段相比)
             :：    密码失效时间 使用时间戳表示。这个时间表示 从第三列的时间戳开始计算时间 到时间后用户失效。即使第五列还有时间也会失效
            最后一列：保留。


        /etc/group 组信息文件
        root:x:0:
            root:   组名
            x:      组密码位，密码文件在/etc/gshadow。组密码默认情况下组只有root用户可以操作，只要有组密码就可以让其他用户对组进行操作。
            0:      组ID号
             ：     此组中支持的其他用户 附加组就是此组的用户
                        初始用户：一个初始用户只能有一个初始组，在创建用户的时候初始组就会自动创建，一般初始组都是和用户名相同
                        附加用户：一个用户可以属于多个附加组。只要把用户加入其他组即可 这样该用户就是其他组的附加用户


                        -------------------------------------------------------------

umask权限
    系统中各种文件的权限设置对特定用户的数据安全有很大影响。但是要求用户逐一明确设置系统中每个文件的权限也是不现实的，
    为此，需要使用umask命令，该命令可以为用户账号中新文件的创建进行缺省设置。系统管理员必须要为你设置一个合理的umask值，
    以确保你创建的文件具有所希望的缺省权限，防止其他非同组用户对你的文件具有写权限。
    具体来说，umask是用来设置权限掩码的，权限掩码由3个数字组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时默认的权限。

    新建的文件 都是有默认权限的
        umask
            查看当前的umask权限

        umask 0022
            临时修改新建目录的权限(永久修改需要修改'/etc/profile'配置文件)
            文件的默认权限002 意思是：666-002=rw- rw- r--
            目录的默认权限是022 意思是：777-022=rw- r-- r--

        umask -S
          u=rwx,g=rwx,x=rwx
            使用字母表示初始权限


                        -------------------------------------------------------------

ACL权限
    ACL权限是用来解决文件的权限不足的问题。
    比如A组下有所属用户A 附加用户B，B有所属组的rw权限。此时如果再来一个用户C 而只让用户C有r读权限，此时就办不到了。
        因为权限只有所属用户权限和所属组权限，不能给C所属组权限 更不能给C所属用户权限。此时就需要ACL权限了。

    ACL权限的方案是：忽略所属组这个概念，把任意组内的用户添加到当前组内 然后给其分配权限。
    但是一旦进行递归之后，不可避免的会出现权限溢出的问题。

    dumpe2fs -h 分区： 查看分区是否开启了acl选项
        mount -o remount,acl： 如果没有开启 就remount(重新挂载) 临时生效
        vi /etc/fstab： 修改配置文件 开启acl选项。永久生效

    getfacl 文件名：        查询文件的ACL权限
    setfacl -m u:st:5 [选项] /www/     给st用户设置5权限 文件是/www/，使用getfcal可以查看acl权限
    setfacl -m u:st:5 -R /www/         -R：递归给目录下所有文件添加权限，只对之前的文件生效
    setfacl -m d:u:st:5 -R /www/       d:：递归给目录下所有文件添加权限，只对之后的文件生效

    setfacl -x u:st /www/              -x：删除st用户的权限
    setfacl -b /www/                   -b：删除www目录的所有权限


                        -------------------------------------------------------------

sudo 授权
    给普通用户赋予部分管理员权限。
    sudo命令赋予普通用户的权限越简单 普通用户得到的权限越大。反之越详细，普通用户得到的权限越小。

    赋予用户执行命令的权力
        sudo -l： 查看被赋予的权限

        visudo： 打开su命令的配置文件，可以给用户添加权限。
            user1   ALL=/usr/bin/vim /xxx/xxx/xxx.conf
                允许user1用户使用vi命令编辑xxx.conf文件( sudo  /usr/bin/vim  /xxx/xxx/xxx.conf )

            user1   ALL=/sbin/shutdown -r now
                给user1用户赋予执行'shutdown'命令的权限 并且只能使用-r now参数，ALL是被管理主机的IP地址。
                不止可以写命令，还可以写脚本的名称 表示赋予执行脚本的权力。

            user1   ALL=/usr/bin/passwd [a-zA-z0-9]*, !/usr/bin/passwd "", !/usr/bin/passwd "root"
                使用正则匹配输入内容。
                如果给别人修改用户密码的权限，那么别人就可以修改root用户的密码了。为了防止这样可以加正则筛选用户输入。

            注意： 当用户执行被分配的权限时，还需要在命令前输入sudo，表示执行root用户赋予的命令。( sudo /usr/sbin/shutdown )

        sudo 被赋予的命令的全路径
            执行当前用户被root用户所分配的命令。不加sudo即使被分配了命令也无法执行。


                        -------------------------------------------------------------

文件的特殊权限SetUID、SetGID、Sticky BIT
    SetUID：比如用户A对文件B没有写入权限，但是用户A有执行命令C的权限 这个命令C又可以修改文件B。
        那么用户A就可以执行命令C 在执行的过程中用户A就会暂时性的变成命令C的'所属者'的身份 有了这个身份就可以修改文件B了。

        比如vim命令，用户A如果对B文件没有任何权限。此时给vim赋予SUID权限，
        那么用户A就可以通过执行vim命令让自己的身份变成vim命令的所有者身份root，此时用户A就可以使用vim命令修改任何文件了。

        这个身份只有在执行命令期间才会生效。命令执行完毕后用户的身份还是原来的。
        SUID表示为' - rws --- --- '，
        chmod 4777 文件： 添加一个SUID权限(4表示SUID 用户权限、 2表示GID 组权限、 1表示BIT 普通用户权限)
        chmod u+s 文件： 给u(用户)添加s(SUID)权限


    SetGID：跟SUID基本一致，SUID改变的是用户的身份。而SGID改变的是用户的所属组。
        SGID要求目录的权限为777
        SGID表示为' - rwx rws rwx '
        chmod 2777 文件
        chmod g+s 文件


    Sticky BIT：粘着位。仅对目录有效
        SBIT要求目录的权限为777。 一旦赋予了黏着位 除了root用户可以删除所有文件，
        普通用户就算拥有w权限，也只能删除自己创建的文件，不能删除其他用户建立的文件

        SGID表示为' - rwx rwx rws '
        chmod 1777 文件
        chmod b+s 文件


                        -------------------------------------------------------------

不可改变位权限 chattr
    不可改变位权限可以对root生效 但是root用户照样可以把这个权限去掉，但是对误删除很有效果

    chattr [+-=] [选项] 文件或目录名
        +：增加权限
        -：删除权限
        =：等于某权限
        i(insert插入)
            如果对文件设置，那么用户就不能对文件进行删除、改名、添加数据、修改数据等操作。
            如果对目录设置，那么就只允许用户对目录下的文件进行修改，不允许建立和删除文件。

        a(append追加)
            如果对文件设置，那么就只能在文件中增加数据，不能删除、修改数据。新增数据的时候不能使用vi，得使用' echo 'x' >> xx '写
            如果对目录设置，那么就只允许用户在目录中建立、修改文件，不允许删除

    lsattr [选项] 文件名
        被chattr添加了i权限以后，使用ll命令是查不到文件的，需要使用lsattr命令才能查看
        -a：显示所有文件和目录
        -d：显示目录的信息 而不是目录下的子文件

--------------------------------------------------------------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------------------------------------------------------

二进制包安装
    windows中有'.exe'的安装程序包，而linux中只有源码包和二进制包。两个系统的包是不能互通的，exe程序在linux中不可能被执行。
    源码包
        开放源代码的包 更加的透明、可以自由的选择所需的功能、软件是编译安装所以更加适合自己的系统 也更加的稳定 效率更高、
        但是也有很多缺点：比如安装过程的步骤较多 尤其是安装较大的软件集合时 容易出现拼写错误、
            编译过程时间较长 安装比二进制安装时间长、因为时编译安装 安装过程中一旦报错很难解决。

    二进制包(rpm包)
        rpm结尾 通过脚本安装包。虽然windows中也有二进制包，但是跟linux还是不通用的
        包安装简单 只需要通过几个命令即可实现包的安装升级查询和拆卸、安装速度也比源码包安装快很多、
        缺点：二进制包不开源、功能选择不如源码包灵活、依赖性问题 有时候安装a包需要先安装b包 但是安装b包的时候又需要安装c包。

        有时候解决依赖性问题会更麻烦，安装一个rpm包可能会需要十几个依赖包，依赖包会出现树形依赖、环形依赖、模块依赖等问题。
        后来官方就推出了' yum '在线安装的方式 会从服务器上下载rpm包，只需要一个yum命令就会自动安装全部的依赖包。

    包的安装过程
        比如有一个依赖：d->f->a->b->c。安装的时候是从下往上安装(cbafd)。卸载的时候是从上往下卸载(dfabc)。
        假如程序包是a，yum命令在卸载的时候就会从上开始卸载df包，此时如果出错需要在把df包安装回去 就办不到了。
        因为yum命令安装的时候是从a包开始安装 只会安装bc包。那么df包就再也安装不回来了。

    service 服务名 start | stop | restart | status
        rpm包大部分都可以通过这种方式启动服务、停止服务、重新启动服务、查看服务状态

    /etc/rc.d/init.d/服务名 start | stop | restart | status
        启动服务等，service命令就是在这个目录下寻找的服务名。如果这个文件中的服务名变了 service启动的服务名也该变。


    包安装
        rpm -ivh 包全名
            安装rpm包，不建议指定位置 会安装到默认路径。
            -i：install安装
            -v：显示更详细的信息
            -h：打印#显示安装进度
            --force：强制重新安装rpm包，当软件中的一些文件丢失时 可以使用此命令重新安装。

            包全名：如果是未安装的软件包 则使用包全名。
            包名：如果操作的是已经安装的软件包，则使用包名即可，系统会产生RPM包的数据库(/var/lib/rpm/)。
            包名跟包全名只在手动安装rpm包的时候区分，yum命令不区分。

        rpm -Uvh 包全名
            -U：安装升级 如果没有安装过 系统直接安装。如果安装过就版本则升级到最新版本

        rpm [选项] 包名
            拆卸rpm包
            -e：拆卸

    包查询
        查询是否已安装
            rpm -q 包名：查询软件包是否已安装
                -a：查询系统中所有软件包
                -p：查询没有安装的软件包

        查询包信息
            rpm -qi 包名：查询软件包的详细信息
            rpm -qip 包全名：查询还没有安装的软件包的详细信息

        查询安装位置
            rpm -ql 包名：查询所有已经安装的软件包和这些包的完整目录
            rpm -qlp 包全名：查询所有还没有安装的软件包和打算安装的位置(默认的安装位置，包的作者决定的)

        查询系统文件属于哪个包
            rpm -qf 系统文件名：查询一个系统文件 即可知道此文件属于哪个软件包

    包验证
        rpm -V 已安装的包名：效验指定的rpm包中的文件
        rpm -Vf 系统文件名：效验某个系统文件是否被修改
            S.5....T.       c           /etc/http/conf/httpd.conf
            其中 S.5....T. 就是效验内容 有八个属性
                S：文件大小是否改变          M：文件的类型或文件的权限(rwx)是否改变
                5：文件MD5效验和是否改变(可以看成文件内容是否改变)              D：设备的主从代码是否改变
                L：文件路径是否改变          U：文件的属主(所有者是否改变)   G：文件的属组是否改变     T：文件的修改时间是否改变

                c：文件类型是配置文件           d：文件类型是普通文件
                g：文件类型是"鬼"文件，就是该文件不应该被这个rpm包包含          l：授权文件               r：描述文件

        要注意的是 包验证有一个原始值，验证的结果就是跟这个原始值作比较，判断值是否发生了改变。
        那么原始值要是被改变了呢？使用数字证书，证书用来保证原始值的安全
            首先需要找到原厂的公钥文件 然后进行安装。安装rpm包的时候就会去提取rpm包中的证书的信息 然后和本机安装的原厂证书进行效验。
            效验通过则允许安装；不通过则不允许安装。证书文件：RPM-GPG-KEY-xxxxxx
            导入数字证书：rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
            查询数字证书：rpm -qa | grep gpg-pubkey


-----------------------------------------------------------------------------------------------------------------------------------------


yum
    linux中没有yum包这一说，yum只是rpm包的一种安装方式。安装位置在/etc/yum.repos.d目录中。
    yum文件目录
        /etc/yum.repos.d/CentOS-Base.repo：基本yum源/网络yum源，会访问网络上的yum仓库进行下载。
        /etc/yum.repos.d/CentOS-Media.repo：光盘yum源/本地yum源，会访问本地光盘上的yum仓库进行下载。

    yum文件的详情
        yum容器名称：[base]
        yum名称：name=CentOS-$releasever - Base
        yum的下载地址：mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os&infra=$infra
        开启数字证书认证：gpgcheck=1
        本地的数字证书位置：gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

    配置本地光盘yum源。先把'/etc/yum.repos.d'目录中的' CentOS-Base.repo '文件后缀改了，这个文件是网络yum源，
    yum会通过后缀名称找这个文件。然后把' CentOS-Media.repo '文件中的baseurl改成光盘挂载的目录/mnt/xxx

    命令
        yum list 包名： 从yum仓库中查找指定的rpm包
        yum search 关键字： 进行模糊查询
        yum [选项] install 包名： 安装包(-y依赖的包全部自动安装 不需要手动确认)
        yum -y update 包名： 升级包。
        yum remove 包名： 拆卸包。不推荐使用，因为拆卸包的时候是依赖树的上面，而安装是安装依赖树的下面，拆卸上面的包后就安装不回来了。

    yum组管理
        yum grouplist：查看可以安装的软件组
        yum groupinfo 软件组名：查看软件组内包含的软件
        yum groupinstall 软件组名：安装软件组内所有软件 -y自动确认
        yum groupremove 软件组名：拆卸软件组内


-----------------------------------------------------------------------------------------------------------------------------------------

源码包安装
    安装源码包的时候必须指定安装位置(/usr/local)。因为rpm包是默认安装，可以使用命令进行拆卸。
    而源码包如果也不指定 安装的时候就会装的到处都是 而且源码包没有安装数据库 没有删除命令。

    安装
        下载源码包。解压到指定目录。进入源码包。
        执行' ./configure --prefix=安装路径(configure命令是大部分的源码包的编译文件 执行就会编译源码包) '、
        执行' mack '进行编译源码包、' mack install '编译安装

    打入补丁
        补丁是靠什么打入的？比较两个文件的不同，把不同的地方打入到包中。
        diff [选项] 文件1 文件2 > 要生成的补丁文件名称
        diff -Naur a.txt b.txt > pat.txt
            比较a.txt和b.txt的区别 生成一个区别文件。这个区别文件就是补丁
            -N：当比较两个目录时，如果某一个文件只在一个目录中，则在另一个中视作空文件
            -a：将任何文档当作当前文本文档处理
            -u：使用统一的输出格式
            -r：当比较目录时，递归比较子目录

        patch -pn < 补丁文件
            把补丁打回去。补丁文件中记录了源文件的信息 所以不需要指定
            -pn： n为数字。代表按照补丁文件中的路径，指定更新文件的位置。
                如果补丁文件中的路径是/root/test，用户当前所在的路径也是/root/test。那么补丁就会打到'/root/test/root/test'下




    快捷键
        Tab：命令或文件名补全
        ctrl+A：把光标移动到命令行开头
        ctrl+E：把光标移动到命令行结尾
        ctrl+C：强制中止当前命令
        ctrl+L：清屏 相当于clear
        ctrl+U：删除或剪切光标之前的命令
        ctrl+Y：粘贴"ctrl+U"剪切的内容

